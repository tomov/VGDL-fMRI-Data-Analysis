% RSA with theory HRRs
% do it manually, b/c we exclude same games (that's regular RSA 1, and not supported by pipeline)
% 
% copied from neurosynth_rsa_HRR and neurosynth_rsa_HRR_groundtruth_avg

clear all;

use_smooth = false;
glmodel = 1;
nperms = 1000;
rsa_idx = 1;
dist = 'correlation';

radius = 6 / 1.5; % 5 mm

if use_smooth
    EXPT = vgdl_expt();
    [whole_brain_mask, Vwhole_brain_mask] = ccnl_load_mask('masks/mask.nii');
else
    EXPT = vgdl_expt_nosmooth();
    [whole_brain_mask, Vwhole_brain_mask] = ccnl_load_mask('masks/mask_nosmooth.nii');
end

subjects = 1:length(EXPT.subject);

what = 'termination';

% get neurosynth ROIs
% % [roi_masks, region] = get_neurosynth_rois(lateralized); too slow
load('mat/get_neurosynth_rois_lat=true'); % generated by get_neurosynth_rois
filename = sprintf('mat/neurosynth_rsa_HRR_groundtruth_full_us=%d_nperms=%d_dist=%s_%s.mat', use_smooth, nperms, dist, what);

% or, searchlight ROIs
% % ROI = get_searchlight_rois(whole_brain_mask, Vwhole_brain_mask, radius);  too slow
%load(sprintf('mat/get_searchlight_rois_us=%d_r=%.4f.mat', use_smooth, radius));
%roi_masks = {ROI.voxel_idx}; % backwards compatibility; they're indices actually, not masks, but it'll do
%filename = sprintf('mat/searchlight_rsa_HRR_groundtruth_full_us=%d_r=%.4f_nperms=%d_%s.mat', use_smooth, radius, nperms, what);

%load('mat/HRR_groundtruth_RDM_correlation.mat'); % game_names, mean_RDM
load(sprintf('mat/HRR_groundtruth_RDM_K=10_N=10_E=0.050_nsamples=100_dist=%s.mat', dist)); % game_names, mean_RDM
game_names = cellfun(@strtrim, mat2cell(game_names, ones(size(game_names, 1), 1)), 'UniformOutput', false);

switch what
    case 'game'
        model_RDM = game_RDM;
    case 'sprite'
        model_RDM = sprite_RDM;
    case 'interaction'
        model_RDM = interaction_RDM;
    case 'termination'
        model_RDM = termination_RDM;
    otherwise
        assert(false);
end

ng = length(game_names);

Behavioral = ccnl_behavioral_rdms(EXPT, rsa_idx, subjects);

% allocate memory
for r = 1:length(roi_masks)
    ROI(r).rho = nan(length(subjects), 1);
    ROI(r).null_rho = nan(length(subjects), nperms);
end

% for each subject
%
for s = 1:length(subjects)
    subj_id = subjects(s);
    subj_id

    n = 18; % RDM length = # of blocks

    [rsa, game_names_ordered] = EXPT.create_rsa(rsa_idx, subj_id);
    assert(rsa.glmodel == glmodel);
    assert(isequal(game_names_ordered', game_names)); % necessary, so features match game #'s in HRR
    assert(size(rsa.model(1).features, 1) == n);

    disp('getting betas and RDMs...');
    tic

    % precompute whole-brain patterns (betas) for each game
    %
    B = ccnl_get_beta_series(EXPT, glmodel, subj_id, 'vgfmri3_', whole_brain_mask);
    assert(size(B,1) == n);
    %B = B(:, ~any(isnan(B), 1));
    assert(~any(isnan(B(:))));

    % calculate HRR RDM based on subject game block order and ground truth HRR RDM
    %
    HRR_RDM = nan(n, n);
    same_game = false(n, n);
    for i = 1:n
        for j = 1:n
            gi = rsa.model(1).features(i);
            gj = rsa.model(1).features(j);
            HRR_RDM(i,j) = model_RDM(gi, gj);
            same_game(i,j) = gi == gj;
        end
    end

    upper = logical(triu(ones(size(HRR_RDM)), 1));
    upper = upper & Behavioral(1).subj(s).partition_RDM & (~same_game); % exclude same partition and same games

    toc
    
    disp('ROIs....');
    tic

    % for each ROI
    %
    for r = 1:length(roi_masks)
        roi_mask = roi_masks{r};

        if mod(r,1) == 0
            r
            toc
            tic
        end

        % subset whole-brain patterns
        U = B(:, roi_mask(whole_brain_mask));

        % compute neural RDM (ccnl_roi_rdms.m)
        neural_RDM = squareRDMs(pdist(U, dist));

        % match RDMs with rank correlation (ccnl_match_rdms.m)
        %
        assert(isequal(size(neural_RDM), size(HRR_RDM)), 'Neural and behavioral RDM sizes should be equal');

        rho = corr(neural_RDM(upper), HRR_RDM(upper), 'type', 'Spearman');
        %[taub, ~, ~, ~, tauz] = ktaub([neural_RDM(upper) HRR_RDM(upper)], 0.05); too slow; untested

        ROI(r).rho(s) = rho;
        %ROI(r).taub(s) = taub;
        %ROI(r).tauz(s) = tauz;

        % null distr
        %
        for k = 1:nperms
            features = rsa.model(1).features([randperm(6) randperm(6)+6 randperm(6)+12]); % from vgdl_create_rsa

            % calculate null HRR RDM from shuffled features
            null_HRR_RDM = nan(n, n);
            null_same_game = false(n, n);
            for i = 1:n
                for j = 1:n
                    null_HRR_RDM(i,j) = model_RDM(features(i), features(j));
                    null_same_game(i,j) = features(i) == features(j);
                end
            end

            % exclude same game based on shuffle
            null_upper = logical(triu(ones(size(HRR_RDM)), 1)) & Behavioral(1).subj(s).partition_RDM & (~null_same_game);

            % important: exclude same game accordingly in neural vs. HRR RDM (think about case when HRR RDM == game ID RDM)
            null_rho = corr(neural_RDM(upper), null_HRR_RDM(null_upper), 'type', 'Spearman');
            %null_taub = ktaub([neural_RDM(upper) HRR_RDM(upper)], 0.05);

            ROI(r).null_rho(s,k) = null_rho;
            %ROI(r).null_taub(s,k) = null_taub;
        end
    end

    toc

end

save(filename, '-v7.3');

% group-level stats
%
for r = 1:length(roi_masks)

    % t-test Spearman rho's
    ROI(r).F = atanh(ROI(r).rho);
    [h,p,ci,stat] = ttest(ROI(r).F);
    ROI(r).t = stat.tstat;
    ROI(r).p = p;

    % t-test Kendall tau's (standardized)
    %{
    [h,p,ci,stat] = ttest(ROI(r).tauz);
    ROI(r).t_k = stat.tstat;
    ROI(r).p_k = p;
    %}

    % note the importance of comparing aggregate statistics to aggregate statistics
    ROI(r).avg_rho = mean(ROI(r).rho, 1); % across subj
    ROI(r).avg_null_rho = [mean(ROI(r).null_rho, 1) ROI(r).avg_rho]; % include actual rho in null
    ROI(r).null_p = mean(ROI(r).avg_rho < ROI(r).avg_null_rho);
    ROI(r).null_z = (ROI(r).avg_rho - mean(ROI(r).avg_null_rho)) / std(ROI(r).avg_null_rho);

    % note the importance of comparing aggregate statistics to aggregate statistics
    %{
    ROI(r).avg_taub = mean(ROI(r).taub, 1); % across subj
    ROI(r).avg_null_taub = [mean(ROI(r).null_taub, 1) ROI(r).avg_taub]; % include actual taub in null
    ROI(r).null_p_k = mean(ROI(r).avg_taub < ROI(r).avg_null_taub);
    ROI(r).null_z_k = (ROI(r).avg_taub - mean(ROI(r).avg_null_taub)) / std(ROI(r).avg_null_taub);
    %}
end

save(filename, '-v7.3');

